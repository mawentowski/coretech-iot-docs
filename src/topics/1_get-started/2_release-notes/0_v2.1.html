<h2 id="v1-to-v2-changes">V1 to V2 Changes</h2>
<p>
    For customers moving from V1 to V2, this section describes some of the basic
    changes you should consider for the new version of the APIs.
</p>
<h3 id="messages-properties">Messages Properties</h3>
<p>
    Service bus messages now have a set of Message Properties (some built in,
    some custom) that assist you as the consumer in deserializing the Message
    Body of the message.
</p>
<p>
    This is a change from the ‘envelope with payload’ format of the v1 messages
    and is an improvement since you only have to deserialize the body one time
    based on the <code>MessageType</code> property.
</p>
<blockquote>
    <p>
        <strong>Note:</strong> A full list of Service Bus Message Types is
        described in the Messages Reference sections.
    </p>
</blockquote>
<p>
    Here’s a brief code snippet that shows the difference between a v1 message
    and a v2 message:
</p>
<pre><code class="language-C#">using Microsoft.Azure.ServiceBus;
using Sita.AirportApi.ServiceBusConsole.Core.Model.FlexCore;
using System.Text;

namespace Sita.AirportApi.ServiceBusConsole.Core.Model
{
    public class DisplayMessage
    {
        public string MessageNamespace { get; set; }
        public string MessageType { get; set; }
        public string MessageVersion { get; set; }
        public string ConnectionId { get; set; }
        public string DeviceId { get; set; }
        public string CorrelationId { get; set; }
        public string Timestamp { get; set; }
        public string MessageBodyJson { get; set; }

        /// &lt;summary&gt;
        /// Create a DisplayMessage object from a Flex Core Platform Message
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;platformMessage&quot;&gt;&lt;/param&gt;
        public DisplayMessage(PlatformMessage platformMessage)
        {
            MessageType = platformMessage.PayloadType;
            MessageVersion = platformMessage.PayloadVersion;
            MessageBodyJson = platformMessage.PayloadAsJson;
        }

        /// &lt;summary&gt;
        /// Create a DisplayMessage object from a Session Management V2 Message
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;platformMessage&quot;&gt;&lt;/param&gt;
        public DisplayMessage(Message message)
        {
            MessageNamespace = message.UserProperties[&quot;MessageNamespace&quot;]?.ToString();
            MessageType = message.UserProperties[&quot;MessageType&quot;]?.ToString();
            MessageVersion = message.UserProperties[&quot;MessageVersion&quot;]?.ToString();
            ConnectionId = message.UserProperties[&quot;ConnectionId&quot;]?.ToString();
            DeviceId = message.UserProperties[&quot;DeviceId&quot;]?.ToString();
            Timestamp = message.UserProperties[&quot;Timestamp&quot;]?.ToString();
            CorrelationId = message.CorrelationId;
            MessageBodyJson = Encoding.UTF8.GetString(message.Body);
        }
    }
}
</code></pre>
<h5
    id="code-snippet-showing-the-difference-between-v1-and-v2-service-bus-messages"
>
    Code Snippet showing the difference between v1 and v2 Service Bus Messages
</h5>
<h3 id="flex-apis-reorganization">Flex APIs Reorganization</h3>
<p>
    Many of the endpoints associated with the V1 Locations API have been
    replaced by the <strong>Session API</strong> endpoints, including requests
    to create Service Bus Subscriptions and connect to devices.
</p>
<p>
    There is <strong>no longer a Peripheral API</strong> that lets you reserve
    and release devices, it has been broken out into separate APIs that deal
    with the different device functions.
</p>
<ul>
    <li>
        For example, printing and scanning devices are now controlled by
        <strong>Print API</strong> and <strong>Scan API</strong>, respectively.
    </li>
    <li>
        The request to reserve a device is now made to the Session API by
        sending a POST <code>/session/v2/connections</code> request, and you may
        use the DEL method to delete the connection (or reservation as referred
        to in V1).
    </li>
</ul>
<h3 id="new-del-methods">New DEL Methods</h3>
<p>
    To conform with REST API standards, some requests initially categorized as
    POST methods that involve the deletion of certain entities are now changed
    to DEL methods. For example:
</p>
<ul>
    <li>
        <p>
            Instead of unsubscribing from a Service Bus Subscription with a POST
            <code>/v1/location/unsubscribe</code> request, you now send a
            <strong>DEL</strong>
            <code>/session/v2/subscriptions/{subscription_id}</code> request.
        </p>
    </li>
    <li>
        <p>
            Instead of releasing a peripheral after reserving it (POST
            <code>/v1/peripheral/release</code>), you send a request to delete
            the connection <strong>DEL</strong>
            <code>/session/v2/connections/{connection_id}</code>.
        </p>
    </li>
</ul>
<p>The GET method will also be incorporated into future releases.</p>
<h3 id="no-session-token">No Session Token</h3>
<p>
    Previously, to use Flex APIs, a
    <code>/v1/location/getsessiontoken</code> request must be made to acquire a
    session token that tracks the session and maps all calls made during the
    session. The Request Body needed to include a <code>LocationID</code> and
    <code>AirlineCode</code>. The request returned the
    <code>SessionToken</code> to be included in the Request Body of all future
    API calls made during the session.
</p>
<p>
    There is no longer a need to request a session token. The
    <code>access_token</code>, included as the <code>bearer_token</code> in
    Authorization Headers, now contains the required information to map your API
    calls during the session. The <code>access_token</code> contains application
    registration details including the application name that contains the
    <code>AirlineCode</code>. Certain roles assigned to that
    <code>AirlineCode</code> govern the allowed interactions with Flex APIs.
</p>
<h3 id="subscribe-request-changes">Subscribe Request Changes</h3>
<p>
    In V1, the response after sending a
    <code>/v1/location/subscribe</code> request included a
    <code>locationCapabilityList</code> with a list of devices at the location
    and their statues. In V2, the <code>/session/v2/subscriptions</code> request
    <em>only returns Service Bus details</em> for the new subscription.
</p>
<p>
    The Service Bus details are largely the same, except some of the property
    names are different.
</p>
<ul>
    <li>
        There is a new <code>Subscription ID</code> that is Flex-specific and
        must be included in all requests connecting to and interacting with
        devices.
    </li>
    <li>
        The <code>serviceBusSharedAccessToken</code> is now contained within the
        <code>connectionString</code> that holds all information required for
        Azure to validate you have access to the Azure Service Bus.
    </li>
    <li>
        The property <code>serviceBusTopic</code> has replaced
        <code>topicName</code> and has a fixed value of
        <code>airline-messages</code> in all situations.
    </li>
    <li>
        The property <code>subscriptionName</code> has replaced
        <code>serviceBusSubscription</code> and is a GUID returned per
        subscription.
    </li>
    <li>
        Both properties <code>serviceBusTopic</code> and
        <code>subscriptionName</code> are identifiers to tell your application
        which specific channel it should read Service Bus messages.
    </li>
</ul>
<h3 id="new-reservation-endpoint">New Reservation Endpoint</h3>
<p>
    The new POST <code>/site/v2/reservations</code> request limits use of a
    location to the airline backend with a specific airline code that made the
    request. The airline backend must reserve the location to make use of its
    devices.
</p>
<h3 id="no-device-status-request">No Device &#39;Status&#39; Request</h3>
<p>
    There is a no longer a <code>/v1/location/status/</code> request available
    to return device statuses at a location. Instead, when you connect to a
    device, a <code>DeviceStatus</code> message is displayed on the Service Bus
    that indicates the device status. When the device status changes in some
    cases, a new message is sent.
</p>
<p>
    The <code>/session/v2/locations/{locationId}</code> returns a list of
    devices and their capabilities, but not their statuses.
</p>
<h3 id="connect-not-reserve">&#39;Connect&#39;, not &#39;Reserve&#39;</h3>
<p>
    The V1 POST <code>/v1/peripheral/reserve</code> request should not be
    confused with the new <code>/site/v2/reservations</code> endpoint, they are
    unrelated. Previously, the purpose of reserving a device was to
    &#39;connect&#39; to it. The new <code>/site/v2/reservations</code> endpoint
    is about reserving a location for exclusive access to its devices.
</p>
<p>
    Instead of &#39;reserving&#39; a device through a POST
    <code>/v1/peripheral/reserve</code> request, you now &#39;connect&#39; to a
    device by making a POST <code>/session/v2/connections</code> request. The
    outcome of the request is the same, to connect to a device to send and
    receive messages.
</p>
<p>
    Instead of passing a <code>LocatorList</code> value to identify the
    peripheral, the IoT Hub identifier <code>deviceID</code> is passed.
</p>
<h3 id="deviceid-instead-of-locator">
    &#39;DeviceID&#39; instead of &#39;Locator&#39;
</h3>
<p>
    The IoT Hub identifier <code>deviceID</code> is now used in requests instead
    of <code>Locator</code>.
</p>
<h3 id="no-transactionid-or-requestid">No TransactionID or RequestID</h3>
<p>
    In V1, the <code>TransactionId</code> property was required to pair certain
    kinds of requests with responses on the Service Bus. In addition, certain
    requests also required a <code>RequestId</code> used by the API to ensure
    that duplicate messages are not processed.
</p>
<p>Both these properties are no longer required.</p>
<h3 id="no-enable-or-disable-devices">
    No &#39;Enable&#39; or &#39;Disable&#39; Devices
</h3>
<p>
    Previously, devices needed to be &#39;enabled&#39; to indicate the
    application is ready to receive data via reading or scanning and
    &#39;disabled&#39; to stop the flow of information from the device to the
    application.
</p>
<p>
    You no longer need to Enable or Disable devices, except for scan devices.
    &#39;Enable&#39; is now POST <code>/scan/v2/startscanning</code> and
    &#39;Disable&#39; is now POST <code>/scan/v2/stopscanning</code>. The
    <code>/scan/v2/startscanning</code> request readies the device to start
    scanning airport documents.
</p>
<h3 id="no-aea-command-request">No AEA Command Request</h3>
<p>
    While it is possible to send an AEA format print request, there is no longer
    the ability to send AEA commands to a device to handle the whole device
    interaction in your application as was possible previously.
</p>
